// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: appcommon.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// App common

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Layer4 Protocol
///
/// LProto indicates which protocol to use for accessing an application on a particular port. This is required by Kubernetes for port mapping.
///
/// 0: `L_PROTO_UNKNOWN`
/// 1: `L_PROTO_TCP`
/// 2: `L_PROTO_UDP`
public enum DistributedMatchEngine_LProto: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown protocol
  case unknown // = 0

  /// TCP (L4) protocol
  case tcp // = 1

  /// UDP (L4) protocol
  case udp // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .tcp
    case 2: self = .udp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .tcp: return 1
    case .udp: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_LProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_LProto] = [
    .unknown,
    .tcp,
    .udp,
  ]
}

#endif  // swift(>=4.2)

/// Health check status
///
/// Health check status gets set by external, or rootLB health check
public enum DistributedMatchEngine_HealthCheck: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Health Check is unknown
  case unknown // = 0

  /// Health Check failure due to RootLB being offline
  case rootlbOffline // = 1

  /// Health Check failure due to Backend server being unavailable
  case serverFail // = 2

  /// Health Check is ok
  case ok // = 3

  /// Health Check failure due to Cloudlet Offline
  case cloudletOffline // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .rootlbOffline
    case 2: self = .serverFail
    case 3: self = .ok
    case 4: self = .cloudletOffline
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .rootlbOffline: return 1
    case .serverFail: return 2
    case .ok: return 3
    case .cloudletOffline: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_HealthCheck: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_HealthCheck] = [
    .unknown,
    .rootlbOffline,
    .serverFail,
    .ok,
    .cloudletOffline,
  ]
}

#endif  // swift(>=4.2)

/// CloudletState is the state of the Cloudlet.
public enum DistributedMatchEngine_CloudletState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown
  case unknown // = 0

  /// Create/Delete/Update encountered errors (see Errors field of CloudletInfo)
  case errors // = 1

  /// Cloudlet is created and ready
  case ready // = 2

  /// Cloudlet is offline (unreachable)
  case offline // = 3

  /// Cloudlet is not present
  case notPresent // = 4

  /// Cloudlet is initializing
  case init_ // = 5

  /// Cloudlet is upgrading
  case upgrade // = 6

  /// Cloudlet needs data to synchronize
  case needSync // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .errors
    case 2: self = .ready
    case 3: self = .offline
    case 4: self = .notPresent
    case 5: self = .init_
    case 6: self = .upgrade
    case 7: self = .needSync
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .errors: return 1
    case .ready: return 2
    case .offline: return 3
    case .notPresent: return 4
    case .init_: return 5
    case .upgrade: return 6
    case .needSync: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_CloudletState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_CloudletState] = [
    .unknown,
    .errors,
    .ready,
    .offline,
    .notPresent,
    .init_,
    .upgrade,
    .needSync,
  ]
}

#endif  // swift(>=4.2)

/// Cloudlet Maintenance States
///
/// Maintenance allows for planned downtimes of Cloudlets.
/// These states involve message exchanges between the Controller,
/// the AutoProv service, and the CRM. Certain states are only set
/// by certain actors.
public enum DistributedMatchEngine_MaintenanceState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Normal operational state
  case normalOperation // = 0

  /// Request start of maintenance
  case maintenanceStart // = 1

  /// Trigger failover for any HA AppInsts
  case failoverRequested // = 2

  /// Failover done
  case failoverDone // = 3

  /// Some errors encountered during maintenance failover
  case failoverError // = 4

  /// Request start of maintenance without AutoProv failover
  case maintenanceStartNoFailover // = 5

  /// Request CRM to transition to maintenance
  case crmRequested // = 6

  /// CRM request done and under maintenance
  case crmUnderMaintenance // = 7

  /// CRM failed to go into maintenance
  case crmError // = 8

  /// Request CRM to transition to normal operation
  case normalOperationInit // = 9

  /// Under maintenance
  case underMaintenance // = 31
  case UNRECOGNIZED(Int)

  public init() {
    self = .normalOperation
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normalOperation
    case 1: self = .maintenanceStart
    case 2: self = .failoverRequested
    case 3: self = .failoverDone
    case 4: self = .failoverError
    case 5: self = .maintenanceStartNoFailover
    case 6: self = .crmRequested
    case 7: self = .crmUnderMaintenance
    case 8: self = .crmError
    case 9: self = .normalOperationInit
    case 31: self = .underMaintenance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normalOperation: return 0
    case .maintenanceStart: return 1
    case .failoverRequested: return 2
    case .failoverDone: return 3
    case .failoverError: return 4
    case .maintenanceStartNoFailover: return 5
    case .crmRequested: return 6
    case .crmUnderMaintenance: return 7
    case .crmError: return 8
    case .normalOperationInit: return 9
    case .underMaintenance: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_MaintenanceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_MaintenanceState] = [
    .normalOperation,
    .maintenanceStart,
    .failoverRequested,
    .failoverDone,
    .failoverError,
    .maintenanceStartNoFailover,
    .crmRequested,
    .crmUnderMaintenance,
    .crmError,
    .normalOperationInit,
    .underMaintenance,
  ]
}

#endif  // swift(>=4.2)

/// Application Port
///
/// AppPort describes an L4 or L7 public access port/path mapping. This is used to track external to internal mappings for access via a shared load balancer or reverse proxy.
public struct DistributedMatchEngine_AppPort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TCP (L4) or UDP (L4) protocol
  public var proto: DistributedMatchEngine_LProto = .unknown

  /// Container port
  public var internalPort: Int32 = 0

  /// Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)
  public var publicPort: Int32 = 0

  /// skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http
  /// FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.
  public var fqdnPrefix: String = String()

  /// A non-zero end port indicates a port range from internal port to end port, inclusive.
  public var endPort: Int32 = 0

  /// TLS termination for this port
  public var tls: Bool = false

  /// Use nginx proxy for this port if you really need a transparent proxy (udp only)
  public var nginx: Bool = false

  /// Maximum datagram size (udp only)
  public var maxPktSize: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// DeviceInfoStatic
public struct DistributedMatchEngine_DeviceInfoStatic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Android or iOS
  public var deviceOs: String = String()

  /// Device model
  public var deviceModel: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// DeviceInfoDynamic
public struct DistributedMatchEngine_DeviceInfoDynamic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// LTE, 5G, etc.
  public var dataNetworkType: String = String()

  /// Device signal strength
  public var signalStrength: UInt64 = 0

  /// Carrier name (can be different from cloudlet org if using "")
  public var carrierName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "distributed_match_engine"

extension DistributedMatchEngine_LProto: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "L_PROTO_UNKNOWN"),
    1: .same(proto: "L_PROTO_TCP"),
    2: .same(proto: "L_PROTO_UDP"),
  ]
}

extension DistributedMatchEngine_HealthCheck: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEALTH_CHECK_UNKNOWN"),
    1: .same(proto: "HEALTH_CHECK_ROOTLB_OFFLINE"),
    2: .same(proto: "HEALTH_CHECK_SERVER_FAIL"),
    3: .same(proto: "HEALTH_CHECK_OK"),
    4: .same(proto: "HEALTH_CHECK_CLOUDLET_OFFLINE"),
  ]
}

extension DistributedMatchEngine_CloudletState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOUDLET_STATE_UNKNOWN"),
    1: .same(proto: "CLOUDLET_STATE_ERRORS"),
    2: .same(proto: "CLOUDLET_STATE_READY"),
    3: .same(proto: "CLOUDLET_STATE_OFFLINE"),
    4: .same(proto: "CLOUDLET_STATE_NOT_PRESENT"),
    5: .same(proto: "CLOUDLET_STATE_INIT"),
    6: .same(proto: "CLOUDLET_STATE_UPGRADE"),
    7: .same(proto: "CLOUDLET_STATE_NEED_SYNC"),
  ]
}

extension DistributedMatchEngine_MaintenanceState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL_OPERATION"),
    1: .same(proto: "MAINTENANCE_START"),
    2: .same(proto: "FAILOVER_REQUESTED"),
    3: .same(proto: "FAILOVER_DONE"),
    4: .same(proto: "FAILOVER_ERROR"),
    5: .same(proto: "MAINTENANCE_START_NO_FAILOVER"),
    6: .same(proto: "CRM_REQUESTED"),
    7: .same(proto: "CRM_UNDER_MAINTENANCE"),
    8: .same(proto: "CRM_ERROR"),
    9: .same(proto: "NORMAL_OPERATION_INIT"),
    31: .same(proto: "UNDER_MAINTENANCE"),
  ]
}

extension DistributedMatchEngine_AppPort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppPort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proto"),
    2: .standard(proto: "internal_port"),
    3: .standard(proto: "public_port"),
    5: .standard(proto: "fqdn_prefix"),
    6: .standard(proto: "end_port"),
    7: .same(proto: "tls"),
    8: .same(proto: "nginx"),
    9: .standard(proto: "max_pkt_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.proto) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.internalPort) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.publicPort) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fqdnPrefix) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.endPort) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.tls) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.nginx) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.maxPktSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proto != .unknown {
      try visitor.visitSingularEnumField(value: self.proto, fieldNumber: 1)
    }
    if self.internalPort != 0 {
      try visitor.visitSingularInt32Field(value: self.internalPort, fieldNumber: 2)
    }
    if self.publicPort != 0 {
      try visitor.visitSingularInt32Field(value: self.publicPort, fieldNumber: 3)
    }
    if !self.fqdnPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.fqdnPrefix, fieldNumber: 5)
    }
    if self.endPort != 0 {
      try visitor.visitSingularInt32Field(value: self.endPort, fieldNumber: 6)
    }
    if self.tls != false {
      try visitor.visitSingularBoolField(value: self.tls, fieldNumber: 7)
    }
    if self.nginx != false {
      try visitor.visitSingularBoolField(value: self.nginx, fieldNumber: 8)
    }
    if self.maxPktSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxPktSize, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_AppPort, rhs: DistributedMatchEngine_AppPort) -> Bool {
    if lhs.proto != rhs.proto {return false}
    if lhs.internalPort != rhs.internalPort {return false}
    if lhs.publicPort != rhs.publicPort {return false}
    if lhs.fqdnPrefix != rhs.fqdnPrefix {return false}
    if lhs.endPort != rhs.endPort {return false}
    if lhs.tls != rhs.tls {return false}
    if lhs.nginx != rhs.nginx {return false}
    if lhs.maxPktSize != rhs.maxPktSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_DeviceInfoStatic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceInfoStatic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_os"),
    2: .standard(proto: "device_model"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceOs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceOs.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceOs, fieldNumber: 1)
    }
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_DeviceInfoStatic, rhs: DistributedMatchEngine_DeviceInfoStatic) -> Bool {
    if lhs.deviceOs != rhs.deviceOs {return false}
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_DeviceInfoDynamic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceInfoDynamic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_network_type"),
    2: .standard(proto: "signal_strength"),
    3: .standard(proto: "carrier_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dataNetworkType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.signalStrength) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataNetworkType.isEmpty {
      try visitor.visitSingularStringField(value: self.dataNetworkType, fieldNumber: 1)
    }
    if self.signalStrength != 0 {
      try visitor.visitSingularUInt64Field(value: self.signalStrength, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_DeviceInfoDynamic, rhs: DistributedMatchEngine_DeviceInfoDynamic) -> Bool {
    if lhs.dataNetworkType != rhs.dataNetworkType {return false}
    if lhs.signalStrength != rhs.signalStrength {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
