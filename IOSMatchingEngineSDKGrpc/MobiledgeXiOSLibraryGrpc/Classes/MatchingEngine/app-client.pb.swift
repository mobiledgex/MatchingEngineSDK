// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app-client.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Device service APIs

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum DistributedMatchEngine_IDTypes: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case idUndefined // = 0
  case imei // = 1
  case msisdn // = 2
  case ipaddr // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .idUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idUndefined
    case 1: self = .imei
    case 2: self = .msisdn
    case 3: self = .ipaddr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .idUndefined: return 0
    case .imei: return 1
    case .msisdn: return 2
    case .ipaddr: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_IDTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_IDTypes] = [
    .idUndefined,
    .imei,
    .msisdn,
    .ipaddr,
  ]
}

#endif  // swift(>=4.2)

public enum DistributedMatchEngine_ReplyStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case rsUndefined // = 0
  case rsSuccess // = 1
  case rsFail // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .rsUndefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rsUndefined
    case 1: self = .rsSuccess
    case 2: self = .rsFail
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rsUndefined: return 0
    case .rsSuccess: return 1
    case .rsFail: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DistributedMatchEngine_ReplyStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_ReplyStatus] = [
    .rsUndefined,
    .rsSuccess,
    .rsFail,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_RegisterClientRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  ///
  /// App Organization Name
  ///
  /// App developer organization name.
  public var orgName: String = String()

  ///
  /// App Name
  ///
  /// Name of your application.
  public var appName: String = String()

  ///
  /// App Version
  ///
  /// Application version.
  public var appVers: String = String()

  ///
  /// Carrier Name
  ///
  /// _(hidden)_ Reserved for future use
  public var carrierName: String = String()

  ///
  /// Authentication Token
  ///
  /// _(optional)_ An authentication token supplied by the application.
  public var authToken: String = String()

  ///
  /// Cell ID
  ///
  /// _(optional)_ Cellular ID of where the client is connected.
  public var cellID: UInt32 = 0

  ///
  /// Unique ID Type
  ///
  /// _(optional)_ Type of unique ID provided by the client.
  /// If left blank, a new Unique ID type will be assigned in the RegisterClient Reply.
  public var uniqueIDType: String = String()

  ///
  /// Unique ID
  ///
  /// _(optional)_ Unique identification of the client device or user. May be overridden by the server.
  /// If left blank, a new Unique ID will be assigned in the RegisterClient Reply.
  public var uniqueID: String = String()

  ///
  /// Tags
  ///
  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_RegisterClientReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Status of the reply
  public var status: DistributedMatchEngine_ReplyStatus = .rsUndefined

  /// Session Cookie to be used in later API calls
  public var sessionCookie: String = String()

  /// URI for the Token Server
  public var tokenServerUri: String = String()

  ///
  /// Unique ID Type
  ///
  /// _(optional)_ Type of unique ID provided by the server
  /// A unique_id_type and unique_id may be provided by the client to be registered.
  /// During registering, if a unique_id_type and unique_id are provided by the client in their request,
  /// the unique_id_type and unique_id will be left blank in the response.
  /// But, if the client does not provide a unique_id_type and unique_id, then the server generates
  /// one and provides the unique_id in the response. If possible, the unique_id should be saved by the
  /// client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be
  /// generated for further API calls.
  public var uniqueIDType: String = String()

  ///
  /// Unique ID
  ///
  /// _(optional)_ Unique identification of the client device or user
  /// A unique_id_type and unique_id may be provided by the client to be registered.
  /// During registering, if a unique_id_type and unique_id are provided by the client in their request,
  /// the unique_id_type and unique_id will be left blank in the response.
  /// But, if the client does not provide a unique_id_type and unique_id, then the server generates
  /// one and provides the unique_id in the response. If possible, the unique_id should be saved by the
  /// client locally and used for subsequent RegisterClient API calls. Otherwise, a new unique_id will be
  /// generated for further API calls.
  public var uniqueID: String = String()

  /// Vendor specific data
  ///
  /// _(optional)_ Array of Tags.
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_FindCloudletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 {
    get {return _storage._ver}
    set {_uniqueStorage()._ver = newValue}
  }

  ///
  /// Session Cookie
  ///
  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String {
    get {return _storage._sessionCookie}
    set {_uniqueStorage()._sessionCookie = newValue}
  }

  ///
  /// Carrier Name
  ///
  /// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
  /// If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
  public var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  ///
  /// GPS Location
  ///
  /// The GPS location of the user
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  ///
  /// Cell ID
  ///
  /// _(optional)_ Cell ID where the client is
  public var cellID: UInt32 {
    get {return _storage._cellID}
    set {_uniqueStorage()._cellID = newValue}
  }

  ///
  /// Device Info
  ///
  /// _(optional)_ Device information for stats
  public var deviceInfo: DistributedMatchEngine_DeviceInfo {
    get {return _storage._deviceInfo ?? DistributedMatchEngine_DeviceInfo()}
    set {_uniqueStorage()._deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return _storage._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {_uniqueStorage()._deviceInfo = nil}

  ///
  /// Tags
  ///
  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct DistributedMatchEngine_PlatformFindCloudletRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  ///
  /// Session Cookie
  ///
  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  ///
  /// Carrier Name
  ///
  /// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
  /// If you wish to search for any app instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
  public var carrierName: String = String()

  ///
  /// Client Token
  ///
  /// Token with encoded client data
  public var clientToken: String = String()

  ///
  /// Device Info
  ///
  /// _(optional)_ Device information for stats
  public var deviceInfo: DistributedMatchEngine_DeviceInfo {
    get {return _deviceInfo ?? DistributedMatchEngine_DeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {self._deviceInfo = nil}

  ///
  /// Tags
  ///
  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceInfo: DistributedMatchEngine_DeviceInfo? = nil
}

public struct DistributedMatchEngine_FindCloudletReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Status return
  public var status: DistributedMatchEngine_FindCloudletReply.FindStatus = .findUnknown

  /// Fully Qualified Domain Name of the Closest App instance
  public var fqdn: String = String()

  /// List of Service Endpoints for AppInst
  public var ports: [DistributedMatchEngine_AppPort] = []

  /// Location of the cloudlet
  public var cloudletLocation: DistributedMatchEngine_Loc {
    get {return _cloudletLocation ?? DistributedMatchEngine_Loc()}
    set {_cloudletLocation = newValue}
  }
  /// Returns true if `cloudletLocation` has been explicitly set.
  public var hasCloudletLocation: Bool {return self._cloudletLocation != nil}
  /// Clears the value of `cloudletLocation`. Subsequent reads from it will return its default value.
  public mutating func clearCloudletLocation() {self._cloudletLocation = nil}

  /// Session Cookie for specific EdgeEvents for specific AppInst
  public var edgeEventsCookie: String = String()

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FindStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case findUnknown // = 0
    case findFound // = 1
    case findNotfound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .findUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .findUnknown
      case 1: self = .findFound
      case 2: self = .findNotfound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .findUnknown: return 0
      case .findFound: return 1
      case .findNotfound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _cloudletLocation: DistributedMatchEngine_Loc? = nil
}

#if swift(>=4.2)

extension DistributedMatchEngine_FindCloudletReply.FindStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_FindCloudletReply.FindStatus] = [
    .findUnknown,
    .findFound,
    .findNotfound,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_VerifyLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  ///
  /// Session Cookie
  ///
  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  ///
  /// Carrier Name
  ///
  /// Unique carrier identification (typically MCC + MNC)
  public var carrierName: String = String()

  ///
  /// GPS Location
  ///
  /// The GPS location to verify
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  ///
  /// Verify Location Token
  ///
  /// Must be retrieved from TokenServerURI
  public var verifyLocToken: String = String()

  ///
  /// Cell ID
  ///
  /// _(optional)_ Cell ID where the client is
  public var cellID: UInt32 = 0

  ///
  /// Tags
  ///
  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gpsLocation: DistributedMatchEngine_Loc? = nil
}

public struct DistributedMatchEngine_VerifyLocationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  public var towerStatus: DistributedMatchEngine_VerifyLocationReply.TowerStatus = .towerUnknown

  public var gpsLocationStatus: DistributedMatchEngine_VerifyLocationReply.GPSLocationStatus = .locUnknown

  /// location accuracy, the location is verified to
  /// be within this number of kilometers.  Negative value
  /// means no verification was performed
  public var gpsLocationAccuracyKm: Double = 0

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  public enum TowerStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case towerUnknown // = 0
    case connectedToSpecifiedTower // = 1
    case notConnectedToSpecifiedTower // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .towerUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .towerUnknown
      case 1: self = .connectedToSpecifiedTower
      case 2: self = .notConnectedToSpecifiedTower
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .towerUnknown: return 0
      case .connectedToSpecifiedTower: return 1
      case .notConnectedToSpecifiedTower: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum GPSLocationStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case locUnknown // = 0
    case locVerified // = 1
    case locMismatchSameCountry // = 2
    case locMismatchOtherCountry // = 3
    case locRoamingCountryMatch // = 4
    case locRoamingCountryMismatch // = 5
    case locErrorUnauthorized // = 6
    case locErrorOther // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .locUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .locUnknown
      case 1: self = .locVerified
      case 2: self = .locMismatchSameCountry
      case 3: self = .locMismatchOtherCountry
      case 4: self = .locRoamingCountryMatch
      case 5: self = .locRoamingCountryMismatch
      case 6: self = .locErrorUnauthorized
      case 7: self = .locErrorOther
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .locUnknown: return 0
      case .locVerified: return 1
      case .locMismatchSameCountry: return 2
      case .locMismatchOtherCountry: return 3
      case .locRoamingCountryMatch: return 4
      case .locRoamingCountryMismatch: return 5
      case .locErrorUnauthorized: return 6
      case .locErrorOther: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_VerifyLocationReply.TowerStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_VerifyLocationReply.TowerStatus] = [
    .towerUnknown,
    .connectedToSpecifiedTower,
    .notConnectedToSpecifiedTower,
  ]
}

extension DistributedMatchEngine_VerifyLocationReply.GPSLocationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_VerifyLocationReply.GPSLocationStatus] = [
    .locUnknown,
    .locVerified,
    .locMismatchSameCountry,
    .locMismatchOtherCountry,
    .locRoamingCountryMatch,
    .locRoamingCountryMismatch,
    .locErrorUnauthorized,
    .locErrorOther,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_GetLocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  /// Unique carrier identification (typically MCC + MNC)
  public var carrierName: String = String()

  /// _(optional)_ Cell id where the client is
  public var cellID: UInt32 = 0

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_GetLocationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  public var status: DistributedMatchEngine_GetLocationReply.LocStatus = .locUnknown

  /// Unique carrier identification (typically MCC + MNC)
  public var carrierName: String = String()

  /// The tower that the user is currently connected to
  public var tower: UInt64 = 0

  /// The GPS location of the user
  public var networkLocation: DistributedMatchEngine_Loc {
    get {return _networkLocation ?? DistributedMatchEngine_Loc()}
    set {_networkLocation = newValue}
  }
  /// Returns true if `networkLocation` has been explicitly set.
  public var hasNetworkLocation: Bool {return self._networkLocation != nil}
  /// Clears the value of `networkLocation`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkLocation() {self._networkLocation = nil}

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  public enum LocStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case locUnknown // = 0
    case locFound // = 1

    /// The user does not allow his location to be tracked
    case locDenied // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .locUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .locUnknown
      case 1: self = .locFound
      case 2: self = .locDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .locUnknown: return 0
      case .locFound: return 1
      case .locDenied: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _networkLocation: DistributedMatchEngine_Loc? = nil
}

#if swift(>=4.2)

extension DistributedMatchEngine_GetLocationReply.LocStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_GetLocationReply.LocStatus] = [
    .locUnknown,
    .locFound,
    .locDenied,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_AppInstListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  ///
  /// Carrier Name
  ///
  /// _(optional)_ By default, all SDKs will automatically fill in this parameter with the MCC+MNC of your current provider. Only override this parameter if you need to filter for a specific carrier on the DME. The DME will filter for App instances that are associated with the specified carrier.
  /// If you wish to search for any App Instance on the DME regardless of carrier name, you can input “” to consider all carriers as “Any”.
  public var carrierName: String = String()

  /// The GPS location of the user
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  /// _(optional)_ Cell id where the client is
  public var cellID: UInt32 = 0

  /// _(optional)_ Limit the number of results, defaults to 3
  public var limit: UInt32 = 0

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gpsLocation: DistributedMatchEngine_Loc? = nil
}

public struct DistributedMatchEngine_Appinstance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// App Instance Name
  public var appName: String = String()

  /// App Instance Version
  public var appVers: String = String()

  /// App Instance FQDN
  public var fqdn: String = String()

  /// ports to access app
  public var ports: [DistributedMatchEngine_AppPort] = []

  /// App Organization Name
  public var orgName: String = String()

  /// Session Cookie for specific EdgeEvents for specific AppInst
  public var edgeEventsCookie: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_CloudletLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cloudlet Organization Name
  public var carrierName: String = String()

  /// Cloudlet Name
  public var cloudletName: String = String()

  /// The GPS Location of the cloudlet
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  /// Distance of cloudlet vs loc in request
  public var distance: Double = 0

  /// App instances
  public var appinstances: [DistributedMatchEngine_Appinstance] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gpsLocation: DistributedMatchEngine_Loc? = nil
}

public struct DistributedMatchEngine_AppInstListReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  public var status: DistributedMatchEngine_AppInstListReply.AIStatus = .aiUndefined

  public var cloudlets: [DistributedMatchEngine_CloudletLocation] = []

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  public enum AIStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case aiUndefined // = 0
    case aiSuccess // = 1
    case aiFail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .aiUndefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .aiUndefined
      case 1: self = .aiSuccess
      case 2: self = .aiFail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .aiUndefined: return 0
      case .aiSuccess: return 1
      case .aiFail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_AppInstListReply.AIStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_AppInstListReply.AIStatus] = [
    .aiUndefined,
    .aiSuccess,
    .aiFail,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_FqdnListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  /// _(optional)_ Cell id where the client is
  public var cellID: UInt32 = 0

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_AppFqdn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// App  Name
  public var appName: String = String()

  /// App Version
  public var appVers: String = String()

  /// App organization name
  public var orgName: String = String()

  /// App FQDN
  public var fqdns: [String] = []

  /// _(optional)_ Android package name
  public var androidPackageName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_FqdnListReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  public var appFqdns: [DistributedMatchEngine_AppFqdn] = []

  public var status: DistributedMatchEngine_FqdnListReply.FLStatus = .flUndefined

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status of the reply
  public enum FLStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case flUndefined // = 0
    case flSuccess // = 1
    case flFail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .flUndefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .flUndefined
      case 1: self = .flSuccess
      case 2: self = .flFail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .flUndefined: return 0
      case .flSuccess: return 1
      case .flFail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_FqdnListReply.FLStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_FqdnListReply.FLStatus] = [
    .flUndefined,
    .flSuccess,
    .flFail,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_AppOfficialFqdnRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  /// The GPS location of the user
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gpsLocation: DistributedMatchEngine_Loc? = nil
}

public struct DistributedMatchEngine_AppOfficialFqdnReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// The FQDN to which the app is reached independent of the edge
  public var appOfficialFqdn: String = String()

  /// Tokenized client data
  public var clientToken: String = String()

  /// Status of the reply
  public var status: DistributedMatchEngine_AppOfficialFqdnReply.AOFStatus = .aofUndefined

  /// List of Service Endpoints for AppInst
  public var ports: [DistributedMatchEngine_AppPort] = []

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AOFStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case aofUndefined // = 0
    case aofSuccess // = 1
    case aofFail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .aofUndefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .aofUndefined
      case 1: self = .aofSuccess
      case 2: self = .aofFail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .aofUndefined: return 0
      case .aofSuccess: return 1
      case .aofFail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_AppOfficialFqdnReply.AOFStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_AppOfficialFqdnReply.AOFStatus] = [
    .aofUndefined,
    .aofSuccess,
    .aofFail,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_DynamicLocGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  /// Dynamic Location Group Id
  public var lgID: UInt64 = 0

  public var commType: DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType = .dlgUndefined

  /// Unused
  public var userData: String = String()

  /// _(optional)_ Cell id where the client is
  public var cellID: UInt32 = 0

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Use Secure communication or Open with the group
  public enum DlgCommType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case dlgUndefined // = 0
    case dlgSecure // = 1
    case dlgOpen // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .dlgUndefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dlgUndefined
      case 1: self = .dlgSecure
      case 2: self = .dlgOpen
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dlgUndefined: return 0
      case .dlgSecure: return 1
      case .dlgOpen: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType] = [
    .dlgUndefined,
    .dlgSecure,
    .dlgOpen,
  ]
}

#endif  // swift(>=4.2)

public struct DistributedMatchEngine_DynamicLocGroupReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Status of the reply
  public var status: DistributedMatchEngine_ReplyStatus = .rsUndefined

  /// Error Code based on Failure
  public var errorCode: UInt32 = 0

  /// Group Cookie for Secure Group Communication
  public var groupCookie: String = String()

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DistributedMatchEngine_QosPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// as set by the client, must be unique within QosRequest
  public var positionid: Int64 = 0

  ///location
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gpsLocation: DistributedMatchEngine_Loc? = nil
}

/// supported band values
public struct DistributedMatchEngine_BandSelection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Radio Access Technologies
  public var rat2G: [String] = []

  public var rat3G: [String] = []

  public var rat4G: [String] = []

  public var rat5G: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// QosPositionRequest is used for both GetQosPositionKpi
public struct DistributedMatchEngine_QosPositionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Session Cookie from RegisterClientRequest
  public var sessionCookie: String = String()

  /// list of positions
  public var positions: [DistributedMatchEngine_QosPosition] = []

  /// _(optional)_ Client's device LTE category number.
  public var lteCategory: Int32 = 0

  /// _(optional)_ Band list used by the client.
  public var bandSelection: DistributedMatchEngine_BandSelection {
    get {return _bandSelection ?? DistributedMatchEngine_BandSelection()}
    set {_bandSelection = newValue}
  }
  /// Returns true if `bandSelection` has been explicitly set.
  public var hasBandSelection: Bool {return self._bandSelection != nil}
  /// Clears the value of `bandSelection`. Subsequent reads from it will return its default value.
  public mutating func clearBandSelection() {self._bandSelection = nil}

  /// _(optional)_ Cell id where the client is
  public var cellID: UInt32 = 0

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _bandSelection: DistributedMatchEngine_BandSelection? = nil
}

public struct DistributedMatchEngine_QosPositionKpiResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// as set by the client, must be unique within one QosPositionRequest
  public var positionid: Int64 {
    get {return _storage._positionid}
    set {_uniqueStorage()._positionid = newValue}
  }

  /// the location which was requested
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  /// throughput
  public var dluserthroughputMin: Float {
    get {return _storage._dluserthroughputMin}
    set {_uniqueStorage()._dluserthroughputMin = newValue}
  }

  public var dluserthroughputAvg: Float {
    get {return _storage._dluserthroughputAvg}
    set {_uniqueStorage()._dluserthroughputAvg = newValue}
  }

  public var dluserthroughputMax: Float {
    get {return _storage._dluserthroughputMax}
    set {_uniqueStorage()._dluserthroughputMax = newValue}
  }

  public var uluserthroughputMin: Float {
    get {return _storage._uluserthroughputMin}
    set {_uniqueStorage()._uluserthroughputMin = newValue}
  }

  public var uluserthroughputAvg: Float {
    get {return _storage._uluserthroughputAvg}
    set {_uniqueStorage()._uluserthroughputAvg = newValue}
  }

  public var uluserthroughputMax: Float {
    get {return _storage._uluserthroughputMax}
    set {_uniqueStorage()._uluserthroughputMax = newValue}
  }

  public var latencyMin: Float {
    get {return _storage._latencyMin}
    set {_uniqueStorage()._latencyMin = newValue}
  }

  public var latencyAvg: Float {
    get {return _storage._latencyAvg}
    set {_uniqueStorage()._latencyAvg = newValue}
  }

  public var latencyMax: Float {
    get {return _storage._latencyMax}
    set {_uniqueStorage()._latencyMax = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct DistributedMatchEngine_QosPositionKpiReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// API version
  ///
  /// _(hidden)_ Reserved for future use
  public var ver: UInt32 = 0

  /// Status of the reply
  public var status: DistributedMatchEngine_ReplyStatus = .rsUndefined

  /// kpi details
  public var positionResults: [DistributedMatchEngine_QosPositionKpiResult] = []

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Messages from SDK to DME
public struct DistributedMatchEngine_ClientEdgeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Session Cookie from RegisterClientReply
  public var sessionCookie: String {
    get {return _storage._sessionCookie}
    set {_uniqueStorage()._sessionCookie = newValue}
  }

  /// Session Cookie from FindCloudletReply 
  public var edgeEventsCookie: String {
    get {return _storage._edgeEventsCookie}
    set {_uniqueStorage()._edgeEventsCookie = newValue}
  }

  public var eventType: DistributedMatchEngine_ClientEdgeEvent.ClientEventType {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  /// GPS Location info if event_type is EVENT_LOCATION_UPDATE or EVENT_LATENCY_SAMPLES
  public var gpsLocation: DistributedMatchEngine_Loc {
    get {return _storage._gpsLocation ?? DistributedMatchEngine_Loc()}
    set {_uniqueStorage()._gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return _storage._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {_uniqueStorage()._gpsLocation = nil}

  /// Latency Samples if event_type is EVENT_LATENCY_SAMPLES or EVENT_CUSTOM_EVENT
  public var samples: [DistributedMatchEngine_Sample] {
    get {return _storage._samples}
    set {_uniqueStorage()._samples = newValue}
  }

  /// Carrier name for EVENT_LATENCY_SAMPLES or EVENT_LOCATION_UPDATE (can be different from cloudlet org if used "")
  public var carrierName: String {
    get {return _storage._carrierName}
    set {_uniqueStorage()._carrierName = newValue}
  }

  /// Device information for stats
  public var deviceInfo: DistributedMatchEngine_DeviceInfo {
    get {return _storage._deviceInfo ?? DistributedMatchEngine_DeviceInfo()}
    set {_uniqueStorage()._deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return _storage._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {_uniqueStorage()._deviceInfo = nil}

  /// Custom event specified by the application
  public var customEvent: String {
    get {return _storage._customEvent}
    set {_uniqueStorage()._customEvent = newValue}
  }

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ClientEventType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case eventUnknown // = 0
    case eventInitConnection // = 1
    case eventTerminateConnection // = 2
    case eventLatencySamples // = 3
    case eventLocationUpdate // = 4
    case eventCustomEvent // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .eventUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .eventUnknown
      case 1: self = .eventInitConnection
      case 2: self = .eventTerminateConnection
      case 3: self = .eventLatencySamples
      case 4: self = .eventLocationUpdate
      case 5: self = .eventCustomEvent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .eventUnknown: return 0
      case .eventInitConnection: return 1
      case .eventTerminateConnection: return 2
      case .eventLatencySamples: return 3
      case .eventLocationUpdate: return 4
      case .eventCustomEvent: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension DistributedMatchEngine_ClientEdgeEvent.ClientEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_ClientEdgeEvent.ClientEventType] = [
    .eventUnknown,
    .eventInitConnection,
    .eventTerminateConnection,
    .eventLatencySamples,
    .eventLocationUpdate,
    .eventCustomEvent,
  ]
}

#endif  // swift(>=4.2)

/// Message from DME to SDK
public struct DistributedMatchEngine_ServerEdgeEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventType: DistributedMatchEngine_ServerEdgeEvent.ServerEventType {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  /// Cloudlet state information
  public var cloudletState: DistributedMatchEngine_CloudletState {
    get {return _storage._cloudletState}
    set {_uniqueStorage()._cloudletState = newValue}
  }

  /// Cloudlet maintenance state information
  public var maintenanceState: DistributedMatchEngine_MaintenanceState {
    get {return _storage._maintenanceState}
    set {_uniqueStorage()._maintenanceState = newValue}
  }

  /// AppInst health state information
  public var healthCheck: DistributedMatchEngine_HealthCheck {
    get {return _storage._healthCheck}
    set {_uniqueStorage()._healthCheck = newValue}
  }

  /// Summarized RTT Latency statis from samples provided from client if event_type is EVENT_LATENCY
  public var statistics: DistributedMatchEngine_Statistics {
    get {return _storage._statistics ?? DistributedMatchEngine_Statistics()}
    set {_uniqueStorage()._statistics = newValue}
  }
  /// Returns true if `statistics` has been explicitly set.
  public var hasStatistics: Bool {return _storage._statistics != nil}
  /// Clears the value of `statistics`. Subsequent reads from it will return its default value.
  public mutating func clearStatistics() {_uniqueStorage()._statistics = nil}

  /// New and closer cloudlet if event_type is EVENT_CLOUDLET_UPDATE
  public var newCloudlet: DistributedMatchEngine_FindCloudletReply {
    get {return _storage._newCloudlet ?? DistributedMatchEngine_FindCloudletReply()}
    set {_uniqueStorage()._newCloudlet = newValue}
  }
  /// Returns true if `newCloudlet` has been explicitly set.
  public var hasNewCloudlet: Bool {return _storage._newCloudlet != nil}
  /// Clears the value of `newCloudlet`. Subsequent reads from it will return its default value.
  public mutating func clearNewCloudlet() {_uniqueStorage()._newCloudlet = nil}

  /// Error message if event_type is EVENT_ERROR
  public var errorMsg: String {
    get {return _storage._errorMsg}
    set {_uniqueStorage()._errorMsg = newValue}
  }

  /// _(optional)_ Vendor specific data
  public var tags: Dictionary<String,String> {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ServerEventType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case eventUnknown // = 0
    case eventInitConnection // = 1
    case eventLatencyRequest // = 2
    case eventLatencyProcessed // = 3
    case eventCloudletState // = 4
    case eventCloudletMaintenance // = 5
    case eventAppinstHealth // = 6
    case eventCloudletUpdate // = 7
    case eventError // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .eventUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .eventUnknown
      case 1: self = .eventInitConnection
      case 2: self = .eventLatencyRequest
      case 3: self = .eventLatencyProcessed
      case 4: self = .eventCloudletState
      case 5: self = .eventCloudletMaintenance
      case 6: self = .eventAppinstHealth
      case 7: self = .eventCloudletUpdate
      case 8: self = .eventError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .eventUnknown: return 0
      case .eventInitConnection: return 1
      case .eventLatencyRequest: return 2
      case .eventLatencyProcessed: return 3
      case .eventCloudletState: return 4
      case .eventCloudletMaintenance: return 5
      case .eventAppinstHealth: return 6
      case .eventCloudletUpdate: return 7
      case .eventError: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension DistributedMatchEngine_ServerEdgeEvent.ServerEventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [DistributedMatchEngine_ServerEdgeEvent.ServerEventType] = [
    .eventUnknown,
    .eventInitConnection,
    .eventLatencyRequest,
    .eventLatencyProcessed,
    .eventCloudletState,
    .eventCloudletMaintenance,
    .eventAppinstHealth,
    .eventCloudletUpdate,
    .eventError,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "distributed_match_engine"

extension DistributedMatchEngine_IDTypes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ID_UNDEFINED"),
    1: .same(proto: "IMEI"),
    2: .same(proto: "MSISDN"),
    3: .same(proto: "IPADDR"),
  ]
}

extension DistributedMatchEngine_ReplyStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RS_UNDEFINED"),
    1: .same(proto: "RS_SUCCESS"),
    2: .same(proto: "RS_FAIL"),
  ]
}

extension DistributedMatchEngine_RegisterClientRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterClientRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "org_name"),
    3: .standard(proto: "app_name"),
    4: .standard(proto: "app_vers"),
    5: .standard(proto: "carrier_name"),
    6: .standard(proto: "auth_token"),
    7: .standard(proto: "cell_id"),
    8: .standard(proto: "unique_id_type"),
    9: .standard(proto: "unique_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orgName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appVers) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.authToken) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.uniqueIDType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.orgName.isEmpty {
      try visitor.visitSingularStringField(value: self.orgName, fieldNumber: 2)
    }
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 3)
    }
    if !self.appVers.isEmpty {
      try visitor.visitSingularStringField(value: self.appVers, fieldNumber: 4)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 5)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authToken, fieldNumber: 6)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 7)
    }
    if !self.uniqueIDType.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueIDType, fieldNumber: 8)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 9)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_RegisterClientRequest, rhs: DistributedMatchEngine_RegisterClientRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.orgName != rhs.orgName {return false}
    if lhs.appName != rhs.appName {return false}
    if lhs.appVers != rhs.appVers {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.uniqueIDType != rhs.uniqueIDType {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_RegisterClientReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterClientReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .standard(proto: "session_cookie"),
    4: .standard(proto: "token_server_uri"),
    5: .standard(proto: "unique_id_type"),
    6: .standard(proto: "unique_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenServerUri) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.uniqueIDType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .rsUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 3)
    }
    if !self.tokenServerUri.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenServerUri, fieldNumber: 4)
    }
    if !self.uniqueIDType.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueIDType, fieldNumber: 5)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_RegisterClientReply, rhs: DistributedMatchEngine_RegisterClientReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.tokenServerUri != rhs.tokenServerUri {return false}
    if lhs.uniqueIDType != rhs.uniqueIDType {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FindCloudletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindCloudletRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "carrier_name"),
    4: .standard(proto: "gps_location"),
    8: .standard(proto: "cell_id"),
    7: .standard(proto: "device_info"),
    100: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _ver: UInt32 = 0
    var _sessionCookie: String = String()
    var _carrierName: String = String()
    var _gpsLocation: DistributedMatchEngine_Loc? = nil
    var _cellID: UInt32 = 0
    var _deviceInfo: DistributedMatchEngine_DeviceInfo? = nil
    var _tags: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ver = source._ver
      _sessionCookie = source._sessionCookie
      _carrierName = source._carrierName
      _gpsLocation = source._gpsLocation
      _cellID = source._cellID
      _deviceInfo = source._deviceInfo
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._ver) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sessionCookie) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._carrierName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._gpsLocation) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deviceInfo) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._cellID) }()
        case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._ver != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ver, fieldNumber: 1)
      }
      if !_storage._sessionCookie.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionCookie, fieldNumber: 2)
      }
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 3)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._deviceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._cellID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._cellID, fieldNumber: 8)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tags, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_FindCloudletRequest, rhs: DistributedMatchEngine_FindCloudletRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ver != rhs_storage._ver {return false}
        if _storage._sessionCookie != rhs_storage._sessionCookie {return false}
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        if _storage._cellID != rhs_storage._cellID {return false}
        if _storage._deviceInfo != rhs_storage._deviceInfo {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_PlatformFindCloudletRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlatformFindCloudletRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "carrier_name"),
    4: .standard(proto: "client_token"),
    5: .standard(proto: "device_info"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientToken) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    if !self.clientToken.isEmpty {
      try visitor.visitSingularStringField(value: self.clientToken, fieldNumber: 4)
    }
    if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_PlatformFindCloudletRequest, rhs: DistributedMatchEngine_PlatformFindCloudletRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.clientToken != rhs.clientToken {return false}
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FindCloudletReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindCloudletReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .same(proto: "fqdn"),
    4: .same(proto: "ports"),
    5: .standard(proto: "cloudlet_location"),
    6: .standard(proto: "edge_events_cookie"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fqdn) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ports) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cloudletLocation) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.edgeEventsCookie) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .findUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.fqdn.isEmpty {
      try visitor.visitSingularStringField(value: self.fqdn, fieldNumber: 3)
    }
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 4)
    }
    if let v = self._cloudletLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.edgeEventsCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.edgeEventsCookie, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_FindCloudletReply, rhs: DistributedMatchEngine_FindCloudletReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.fqdn != rhs.fqdn {return false}
    if lhs.ports != rhs.ports {return false}
    if lhs._cloudletLocation != rhs._cloudletLocation {return false}
    if lhs.edgeEventsCookie != rhs.edgeEventsCookie {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FindCloudletReply.FindStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIND_UNKNOWN"),
    1: .same(proto: "FIND_FOUND"),
    2: .same(proto: "FIND_NOTFOUND"),
  ]
}

extension DistributedMatchEngine_VerifyLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyLocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "carrier_name"),
    4: .standard(proto: "gps_location"),
    5: .standard(proto: "verify_loc_token"),
    6: .standard(proto: "cell_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.verifyLocToken) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.verifyLocToken.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyLocToken, fieldNumber: 5)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_VerifyLocationRequest, rhs: DistributedMatchEngine_VerifyLocationRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.verifyLocToken != rhs.verifyLocToken {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_VerifyLocationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyLocationReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "tower_status"),
    3: .standard(proto: "gps_location_status"),
    4: .standard(proto: "gps_location_accuracy_km"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.towerStatus) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.gpsLocationStatus) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.gpsLocationAccuracyKm) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.towerStatus != .towerUnknown {
      try visitor.visitSingularEnumField(value: self.towerStatus, fieldNumber: 2)
    }
    if self.gpsLocationStatus != .locUnknown {
      try visitor.visitSingularEnumField(value: self.gpsLocationStatus, fieldNumber: 3)
    }
    if self.gpsLocationAccuracyKm != 0 {
      try visitor.visitSingularDoubleField(value: self.gpsLocationAccuracyKm, fieldNumber: 4)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_VerifyLocationReply, rhs: DistributedMatchEngine_VerifyLocationReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.towerStatus != rhs.towerStatus {return false}
    if lhs.gpsLocationStatus != rhs.gpsLocationStatus {return false}
    if lhs.gpsLocationAccuracyKm != rhs.gpsLocationAccuracyKm {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_VerifyLocationReply.TowerStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOWER_UNKNOWN"),
    1: .same(proto: "CONNECTED_TO_SPECIFIED_TOWER"),
    2: .same(proto: "NOT_CONNECTED_TO_SPECIFIED_TOWER"),
  ]
}

extension DistributedMatchEngine_VerifyLocationReply.GPSLocationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOC_UNKNOWN"),
    1: .same(proto: "LOC_VERIFIED"),
    2: .same(proto: "LOC_MISMATCH_SAME_COUNTRY"),
    3: .same(proto: "LOC_MISMATCH_OTHER_COUNTRY"),
    4: .same(proto: "LOC_ROAMING_COUNTRY_MATCH"),
    5: .same(proto: "LOC_ROAMING_COUNTRY_MISMATCH"),
    6: .same(proto: "LOC_ERROR_UNAUTHORIZED"),
    7: .same(proto: "LOC_ERROR_OTHER"),
  ]
}

extension DistributedMatchEngine_GetLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "carrier_name"),
    4: .standard(proto: "cell_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 4)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_GetLocationRequest, rhs: DistributedMatchEngine_GetLocationRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_GetLocationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetLocationReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .standard(proto: "carrier_name"),
    4: .same(proto: "tower"),
    5: .standard(proto: "network_location"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.tower) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._networkLocation) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .locUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    if self.tower != 0 {
      try visitor.visitSingularUInt64Field(value: self.tower, fieldNumber: 4)
    }
    if let v = self._networkLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_GetLocationReply, rhs: DistributedMatchEngine_GetLocationReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.tower != rhs.tower {return false}
    if lhs._networkLocation != rhs._networkLocation {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_GetLocationReply.LocStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOC_UNKNOWN"),
    1: .same(proto: "LOC_FOUND"),
    2: .same(proto: "LOC_DENIED"),
  ]
}

extension DistributedMatchEngine_AppInstListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppInstListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "carrier_name"),
    4: .standard(proto: "gps_location"),
    5: .standard(proto: "cell_id"),
    6: .same(proto: "limit"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 3)
    }
    if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 5)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_AppInstListRequest, rhs: DistributedMatchEngine_AppInstListRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_Appinstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Appinstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_name"),
    2: .standard(proto: "app_vers"),
    3: .same(proto: "fqdn"),
    4: .same(proto: "ports"),
    5: .standard(proto: "org_name"),
    6: .standard(proto: "edge_events_cookie"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appVers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fqdn) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ports) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orgName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.edgeEventsCookie) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 1)
    }
    if !self.appVers.isEmpty {
      try visitor.visitSingularStringField(value: self.appVers, fieldNumber: 2)
    }
    if !self.fqdn.isEmpty {
      try visitor.visitSingularStringField(value: self.fqdn, fieldNumber: 3)
    }
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 4)
    }
    if !self.orgName.isEmpty {
      try visitor.visitSingularStringField(value: self.orgName, fieldNumber: 5)
    }
    if !self.edgeEventsCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.edgeEventsCookie, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_Appinstance, rhs: DistributedMatchEngine_Appinstance) -> Bool {
    if lhs.appName != rhs.appName {return false}
    if lhs.appVers != rhs.appVers {return false}
    if lhs.fqdn != rhs.fqdn {return false}
    if lhs.ports != rhs.ports {return false}
    if lhs.orgName != rhs.orgName {return false}
    if lhs.edgeEventsCookie != rhs.edgeEventsCookie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_CloudletLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudletLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "carrier_name"),
    2: .standard(proto: "cloudlet_name"),
    3: .standard(proto: "gps_location"),
    4: .same(proto: "distance"),
    5: .same(proto: "appinstances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.carrierName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cloudletName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.distance) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.appinstances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.carrierName.isEmpty {
      try visitor.visitSingularStringField(value: self.carrierName, fieldNumber: 1)
    }
    if !self.cloudletName.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudletName, fieldNumber: 2)
    }
    if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.distance != 0 {
      try visitor.visitSingularDoubleField(value: self.distance, fieldNumber: 4)
    }
    if !self.appinstances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appinstances, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_CloudletLocation, rhs: DistributedMatchEngine_CloudletLocation) -> Bool {
    if lhs.carrierName != rhs.carrierName {return false}
    if lhs.cloudletName != rhs.cloudletName {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.appinstances != rhs.appinstances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppInstListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppInstListReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .same(proto: "cloudlets"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cloudlets) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .aiUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.cloudlets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cloudlets, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_AppInstListReply, rhs: DistributedMatchEngine_AppInstListReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.cloudlets != rhs.cloudlets {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppInstListReply.AIStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AI_UNDEFINED"),
    1: .same(proto: "AI_SUCCESS"),
    2: .same(proto: "AI_FAIL"),
  ]
}

extension DistributedMatchEngine_FqdnListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FqdnListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "cell_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_FqdnListRequest, rhs: DistributedMatchEngine_FqdnListRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppFqdn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppFqdn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_name"),
    2: .standard(proto: "app_vers"),
    3: .standard(proto: "org_name"),
    4: .same(proto: "fqdns"),
    5: .standard(proto: "android_package_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appVers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orgName) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.fqdns) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.androidPackageName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 1)
    }
    if !self.appVers.isEmpty {
      try visitor.visitSingularStringField(value: self.appVers, fieldNumber: 2)
    }
    if !self.orgName.isEmpty {
      try visitor.visitSingularStringField(value: self.orgName, fieldNumber: 3)
    }
    if !self.fqdns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fqdns, fieldNumber: 4)
    }
    if !self.androidPackageName.isEmpty {
      try visitor.visitSingularStringField(value: self.androidPackageName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_AppFqdn, rhs: DistributedMatchEngine_AppFqdn) -> Bool {
    if lhs.appName != rhs.appName {return false}
    if lhs.appVers != rhs.appVers {return false}
    if lhs.orgName != rhs.orgName {return false}
    if lhs.fqdns != rhs.fqdns {return false}
    if lhs.androidPackageName != rhs.androidPackageName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FqdnListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FqdnListReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    3: .standard(proto: "app_fqdns"),
    4: .same(proto: "status"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.appFqdns) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.appFqdns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appFqdns, fieldNumber: 3)
    }
    if self.status != .flUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_FqdnListReply, rhs: DistributedMatchEngine_FqdnListReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.appFqdns != rhs.appFqdns {return false}
    if lhs.status != rhs.status {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_FqdnListReply.FLStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FL_UNDEFINED"),
    1: .same(proto: "FL_SUCCESS"),
    2: .same(proto: "FL_FAIL"),
  ]
}

extension DistributedMatchEngine_AppOfficialFqdnRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppOfficialFqdnRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "gps_location"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_AppOfficialFqdnRequest, rhs: DistributedMatchEngine_AppOfficialFqdnRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppOfficialFqdnReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppOfficialFqdnReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "app_official_fqdn"),
    3: .standard(proto: "client_token"),
    4: .same(proto: "status"),
    5: .same(proto: "ports"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appOfficialFqdn) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientToken) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.ports) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.appOfficialFqdn.isEmpty {
      try visitor.visitSingularStringField(value: self.appOfficialFqdn, fieldNumber: 2)
    }
    if !self.clientToken.isEmpty {
      try visitor.visitSingularStringField(value: self.clientToken, fieldNumber: 3)
    }
    if self.status != .aofUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 5)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_AppOfficialFqdnReply, rhs: DistributedMatchEngine_AppOfficialFqdnReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.appOfficialFqdn != rhs.appOfficialFqdn {return false}
    if lhs.clientToken != rhs.clientToken {return false}
    if lhs.status != rhs.status {return false}
    if lhs.ports != rhs.ports {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_AppOfficialFqdnReply.AOFStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AOF_UNDEFINED"),
    1: .same(proto: "AOF_SUCCESS"),
    2: .same(proto: "AOF_FAIL"),
  ]
}

extension DistributedMatchEngine_DynamicLocGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicLocGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .standard(proto: "lg_id"),
    11: .standard(proto: "comm_type"),
    12: .standard(proto: "user_data"),
    13: .standard(proto: "cell_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.lgID) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.commType) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.userData) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if self.lgID != 0 {
      try visitor.visitSingularUInt64Field(value: self.lgID, fieldNumber: 3)
    }
    if self.commType != .dlgUndefined {
      try visitor.visitSingularEnumField(value: self.commType, fieldNumber: 11)
    }
    if !self.userData.isEmpty {
      try visitor.visitSingularStringField(value: self.userData, fieldNumber: 12)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 13)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_DynamicLocGroupRequest, rhs: DistributedMatchEngine_DynamicLocGroupRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.lgID != rhs.lgID {return false}
    if lhs.commType != rhs.commType {return false}
    if lhs.userData != rhs.userData {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_DynamicLocGroupRequest.DlgCommType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DLG_UNDEFINED"),
    1: .same(proto: "DLG_SECURE"),
    2: .same(proto: "DLG_OPEN"),
  ]
}

extension DistributedMatchEngine_DynamicLocGroupReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicLocGroupReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .standard(proto: "error_code"),
    5: .standard(proto: "group_cookie"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.errorCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.groupCookie) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .rsUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.errorCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorCode, fieldNumber: 3)
    }
    if !self.groupCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.groupCookie, fieldNumber: 5)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_DynamicLocGroupReply, rhs: DistributedMatchEngine_DynamicLocGroupReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.groupCookie != rhs.groupCookie {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_QosPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QosPosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "positionid"),
    2: .standard(proto: "gps_location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.positionid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.positionid != 0 {
      try visitor.visitSingularInt64Field(value: self.positionid, fieldNumber: 1)
    }
    if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_QosPosition, rhs: DistributedMatchEngine_QosPosition) -> Bool {
    if lhs.positionid != rhs.positionid {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_BandSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BandSelection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rat_2g"),
    2: .standard(proto: "rat_3g"),
    3: .standard(proto: "rat_4g"),
    4: .standard(proto: "rat_5g"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.rat2G) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.rat3G) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.rat4G) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.rat5G) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rat2G.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rat2G, fieldNumber: 1)
    }
    if !self.rat3G.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rat3G, fieldNumber: 2)
    }
    if !self.rat4G.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rat4G, fieldNumber: 3)
    }
    if !self.rat5G.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rat5G, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_BandSelection, rhs: DistributedMatchEngine_BandSelection) -> Bool {
    if lhs.rat2G != rhs.rat2G {return false}
    if lhs.rat3G != rhs.rat3G {return false}
    if lhs.rat4G != rhs.rat4G {return false}
    if lhs.rat5G != rhs.rat5G {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_QosPositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QosPositionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .standard(proto: "session_cookie"),
    3: .same(proto: "positions"),
    4: .standard(proto: "lte_category"),
    5: .standard(proto: "band_selection"),
    6: .standard(proto: "cell_id"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionCookie) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.positions) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.lteCategory) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bandSelection) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.cellID) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if !self.sessionCookie.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionCookie, fieldNumber: 2)
    }
    if !self.positions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positions, fieldNumber: 3)
    }
    if self.lteCategory != 0 {
      try visitor.visitSingularInt32Field(value: self.lteCategory, fieldNumber: 4)
    }
    if let v = self._bandSelection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.cellID != 0 {
      try visitor.visitSingularUInt32Field(value: self.cellID, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_QosPositionRequest, rhs: DistributedMatchEngine_QosPositionRequest) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.sessionCookie != rhs.sessionCookie {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.lteCategory != rhs.lteCategory {return false}
    if lhs._bandSelection != rhs._bandSelection {return false}
    if lhs.cellID != rhs.cellID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_QosPositionKpiResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QosPositionKpiResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "positionid"),
    2: .standard(proto: "gps_location"),
    3: .standard(proto: "dluserthroughput_min"),
    4: .standard(proto: "dluserthroughput_avg"),
    5: .standard(proto: "dluserthroughput_max"),
    6: .standard(proto: "uluserthroughput_min"),
    7: .standard(proto: "uluserthroughput_avg"),
    8: .standard(proto: "uluserthroughput_max"),
    9: .standard(proto: "latency_min"),
    10: .standard(proto: "latency_avg"),
    11: .standard(proto: "latency_max"),
  ]

  fileprivate class _StorageClass {
    var _positionid: Int64 = 0
    var _gpsLocation: DistributedMatchEngine_Loc? = nil
    var _dluserthroughputMin: Float = 0
    var _dluserthroughputAvg: Float = 0
    var _dluserthroughputMax: Float = 0
    var _uluserthroughputMin: Float = 0
    var _uluserthroughputAvg: Float = 0
    var _uluserthroughputMax: Float = 0
    var _latencyMin: Float = 0
    var _latencyAvg: Float = 0
    var _latencyMax: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionid = source._positionid
      _gpsLocation = source._gpsLocation
      _dluserthroughputMin = source._dluserthroughputMin
      _dluserthroughputAvg = source._dluserthroughputAvg
      _dluserthroughputMax = source._dluserthroughputMax
      _uluserthroughputMin = source._uluserthroughputMin
      _uluserthroughputAvg = source._uluserthroughputAvg
      _uluserthroughputMax = source._uluserthroughputMax
      _latencyMin = source._latencyMin
      _latencyAvg = source._latencyAvg
      _latencyMax = source._latencyMax
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._positionid) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gpsLocation) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._dluserthroughputMin) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._dluserthroughputAvg) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._dluserthroughputMax) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._uluserthroughputMin) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._uluserthroughputAvg) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._uluserthroughputMax) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._latencyMin) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._latencyAvg) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._latencyMax) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._positionid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._positionid, fieldNumber: 1)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._dluserthroughputMin != 0 {
        try visitor.visitSingularFloatField(value: _storage._dluserthroughputMin, fieldNumber: 3)
      }
      if _storage._dluserthroughputAvg != 0 {
        try visitor.visitSingularFloatField(value: _storage._dluserthroughputAvg, fieldNumber: 4)
      }
      if _storage._dluserthroughputMax != 0 {
        try visitor.visitSingularFloatField(value: _storage._dluserthroughputMax, fieldNumber: 5)
      }
      if _storage._uluserthroughputMin != 0 {
        try visitor.visitSingularFloatField(value: _storage._uluserthroughputMin, fieldNumber: 6)
      }
      if _storage._uluserthroughputAvg != 0 {
        try visitor.visitSingularFloatField(value: _storage._uluserthroughputAvg, fieldNumber: 7)
      }
      if _storage._uluserthroughputMax != 0 {
        try visitor.visitSingularFloatField(value: _storage._uluserthroughputMax, fieldNumber: 8)
      }
      if _storage._latencyMin != 0 {
        try visitor.visitSingularFloatField(value: _storage._latencyMin, fieldNumber: 9)
      }
      if _storage._latencyAvg != 0 {
        try visitor.visitSingularFloatField(value: _storage._latencyAvg, fieldNumber: 10)
      }
      if _storage._latencyMax != 0 {
        try visitor.visitSingularFloatField(value: _storage._latencyMax, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_QosPositionKpiResult, rhs: DistributedMatchEngine_QosPositionKpiResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._positionid != rhs_storage._positionid {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        if _storage._dluserthroughputMin != rhs_storage._dluserthroughputMin {return false}
        if _storage._dluserthroughputAvg != rhs_storage._dluserthroughputAvg {return false}
        if _storage._dluserthroughputMax != rhs_storage._dluserthroughputMax {return false}
        if _storage._uluserthroughputMin != rhs_storage._uluserthroughputMin {return false}
        if _storage._uluserthroughputAvg != rhs_storage._uluserthroughputAvg {return false}
        if _storage._uluserthroughputMax != rhs_storage._uluserthroughputMax {return false}
        if _storage._latencyMin != rhs_storage._latencyMin {return false}
        if _storage._latencyAvg != rhs_storage._latencyAvg {return false}
        if _storage._latencyMax != rhs_storage._latencyMax {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_QosPositionKpiReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QosPositionKpiReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ver"),
    2: .same(proto: "status"),
    3: .standard(proto: "position_results"),
    100: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.ver) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.positionResults) }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ver != 0 {
      try visitor.visitSingularUInt32Field(value: self.ver, fieldNumber: 1)
    }
    if self.status != .rsUndefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.positionResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positionResults, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_QosPositionKpiReply, rhs: DistributedMatchEngine_QosPositionKpiReply) -> Bool {
    if lhs.ver != rhs.ver {return false}
    if lhs.status != rhs.status {return false}
    if lhs.positionResults != rhs.positionResults {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_ClientEdgeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientEdgeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_cookie"),
    2: .standard(proto: "edge_events_cookie"),
    3: .standard(proto: "event_type"),
    4: .standard(proto: "gps_location"),
    5: .same(proto: "samples"),
    6: .standard(proto: "carrier_name"),
    7: .standard(proto: "device_info"),
    8: .standard(proto: "custom_event"),
    100: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _sessionCookie: String = String()
    var _edgeEventsCookie: String = String()
    var _eventType: DistributedMatchEngine_ClientEdgeEvent.ClientEventType = .eventUnknown
    var _gpsLocation: DistributedMatchEngine_Loc? = nil
    var _samples: [DistributedMatchEngine_Sample] = []
    var _carrierName: String = String()
    var _deviceInfo: DistributedMatchEngine_DeviceInfo? = nil
    var _customEvent: String = String()
    var _tags: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sessionCookie = source._sessionCookie
      _edgeEventsCookie = source._edgeEventsCookie
      _eventType = source._eventType
      _gpsLocation = source._gpsLocation
      _samples = source._samples
      _carrierName = source._carrierName
      _deviceInfo = source._deviceInfo
      _customEvent = source._customEvent
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sessionCookie) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._edgeEventsCookie) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._eventType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._gpsLocation) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._samples) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._carrierName) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deviceInfo) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._customEvent) }()
        case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sessionCookie.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionCookie, fieldNumber: 1)
      }
      if !_storage._edgeEventsCookie.isEmpty {
        try visitor.visitSingularStringField(value: _storage._edgeEventsCookie, fieldNumber: 2)
      }
      if _storage._eventType != .eventUnknown {
        try visitor.visitSingularEnumField(value: _storage._eventType, fieldNumber: 3)
      }
      if let v = _storage._gpsLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._samples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._samples, fieldNumber: 5)
      }
      if !_storage._carrierName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._carrierName, fieldNumber: 6)
      }
      if let v = _storage._deviceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._customEvent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customEvent, fieldNumber: 8)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tags, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_ClientEdgeEvent, rhs: DistributedMatchEngine_ClientEdgeEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sessionCookie != rhs_storage._sessionCookie {return false}
        if _storage._edgeEventsCookie != rhs_storage._edgeEventsCookie {return false}
        if _storage._eventType != rhs_storage._eventType {return false}
        if _storage._gpsLocation != rhs_storage._gpsLocation {return false}
        if _storage._samples != rhs_storage._samples {return false}
        if _storage._carrierName != rhs_storage._carrierName {return false}
        if _storage._deviceInfo != rhs_storage._deviceInfo {return false}
        if _storage._customEvent != rhs_storage._customEvent {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_ClientEdgeEvent.ClientEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_UNKNOWN"),
    1: .same(proto: "EVENT_INIT_CONNECTION"),
    2: .same(proto: "EVENT_TERMINATE_CONNECTION"),
    3: .same(proto: "EVENT_LATENCY_SAMPLES"),
    4: .same(proto: "EVENT_LOCATION_UPDATE"),
    5: .same(proto: "EVENT_CUSTOM_EVENT"),
  ]
}

extension DistributedMatchEngine_ServerEdgeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerEdgeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .standard(proto: "cloudlet_state"),
    3: .standard(proto: "maintenance_state"),
    4: .standard(proto: "health_check"),
    5: .same(proto: "statistics"),
    6: .standard(proto: "new_cloudlet"),
    7: .standard(proto: "error_msg"),
    100: .same(proto: "tags"),
  ]

  fileprivate class _StorageClass {
    var _eventType: DistributedMatchEngine_ServerEdgeEvent.ServerEventType = .eventUnknown
    var _cloudletState: DistributedMatchEngine_CloudletState = .unknown
    var _maintenanceState: DistributedMatchEngine_MaintenanceState = .normalOperation
    var _healthCheck: DistributedMatchEngine_HealthCheck = .unknown
    var _statistics: DistributedMatchEngine_Statistics? = nil
    var _newCloudlet: DistributedMatchEngine_FindCloudletReply? = nil
    var _errorMsg: String = String()
    var _tags: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _eventType = source._eventType
      _cloudletState = source._cloudletState
      _maintenanceState = source._maintenanceState
      _healthCheck = source._healthCheck
      _statistics = source._statistics
      _newCloudlet = source._newCloudlet
      _errorMsg = source._errorMsg
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._eventType) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._cloudletState) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._maintenanceState) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._healthCheck) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._statistics) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._newCloudlet) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._errorMsg) }()
        case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._eventType != .eventUnknown {
        try visitor.visitSingularEnumField(value: _storage._eventType, fieldNumber: 1)
      }
      if _storage._cloudletState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._cloudletState, fieldNumber: 2)
      }
      if _storage._maintenanceState != .normalOperation {
        try visitor.visitSingularEnumField(value: _storage._maintenanceState, fieldNumber: 3)
      }
      if _storage._healthCheck != .unknown {
        try visitor.visitSingularEnumField(value: _storage._healthCheck, fieldNumber: 4)
      }
      if let v = _storage._statistics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._newCloudlet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._errorMsg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMsg, fieldNumber: 7)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tags, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DistributedMatchEngine_ServerEdgeEvent, rhs: DistributedMatchEngine_ServerEdgeEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._eventType != rhs_storage._eventType {return false}
        if _storage._cloudletState != rhs_storage._cloudletState {return false}
        if _storage._maintenanceState != rhs_storage._maintenanceState {return false}
        if _storage._healthCheck != rhs_storage._healthCheck {return false}
        if _storage._statistics != rhs_storage._statistics {return false}
        if _storage._newCloudlet != rhs_storage._newCloudlet {return false}
        if _storage._errorMsg != rhs_storage._errorMsg {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DistributedMatchEngine_ServerEdgeEvent.ServerEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_UNKNOWN"),
    1: .same(proto: "EVENT_INIT_CONNECTION"),
    2: .same(proto: "EVENT_LATENCY_REQUEST"),
    3: .same(proto: "EVENT_LATENCY_PROCESSED"),
    4: .same(proto: "EVENT_CLOUDLET_STATE"),
    5: .same(proto: "EVENT_CLOUDLET_MAINTENANCE"),
    6: .same(proto: "EVENT_APPINST_HEALTH"),
    7: .same(proto: "EVENT_CLOUDLET_UPDATE"),
    8: .same(proto: "EVENT_ERROR"),
  ]
}
